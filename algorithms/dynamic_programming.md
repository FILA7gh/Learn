
Динамическое программирование (Dynamic Programming, DP) — это метод алгоритмического решения задач,
который разбивает сложную задачу на более простые подзадачи и сохраняет результаты этих подзадач
для предотвращения повторных вычислений. Этот метод особенно эффективен для задач,
которые могут быть разбиты на перекрывающиеся подзадачи и оптимальные подструктуры.


Основные концепции динамического программирования:

    Перекрывающиеся подзадачи (Overlapping Subproblems):
        Задача может быть разбита на подзадачи, которые решаются многократно.


    Оптимальные подструктуры (Optimal Substructure):
        Оптимальное решение исходной задачи может быть построено из оптимальных решений её подзадач.


    Мемоизация (Memoization):
        Хранение результатов подзадач для предотвращения их повторного вычисления (используется в топ-даун подходе).


    Табулирование (Tabulation):
        Заполнение таблицы решениями подзадач в итеративной форме (используется в боттом-ап подходе).



Подходы к динамическому программированию:

    Топ-даун (с мемоизацией):
        Решение задачи начинается с её верхнего уровня, и подзадачи решаются по мере необходимости.
        Результаты подзадач сохраняются в памяти, чтобы избежать повторных вычислений.


    Боттом-ап (с табулированием):
        Решение задачи начинается с самых простых подзадач, результаты которых записываются в таблицу,
        и используются для построения решения более сложных подзадач.


Примеры задач, решаемых с помощью динамического программирования:

    1. Задача о нахождении чисел Фибоначчи

        Числа Фибоначчи могут быть вычислены как:
        F(n)=F(n−1)+F(n−2)F(n)=F(n−1)+F(n−2)
        с начальными условиями F(0)=0F(0)=0 и F(1)=1F(1)=1.

        Топ-даун подход:

            def fib_memo(n, memo={}):
                if n in memo:
                    return memo[n]
                if n <= 1:
                    return n
                memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
                return memo[n]

            # Пример использования
            print(fib_memo(10))  # Output: 55


        Боттом-ап подход:

            def fib_tab(n):
                if n <= 1:
                    return n
                dp = [0] * (n + 1)
                dp[1] = 1
                for i in range(2, n + 1):
                    dp[i] = dp[i-1] + dp[i-2]
                return dp[n]

            # Пример использования
            print(fib_tab(10))  # Output: 55


    2. Задача о рюкзаке (0/1 Knapsack Problem)

        Дана масса рюкзака WW и набор предметов, каждый из которых имеет вес и стоимость.
        Нужно найти максимальную стоимость набора предметов, который можно унести в рюкзаке.

        Боттом-ап подход:

            def knapsack(values, weights, W):
                n = len(values)
                dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]

                for i in range(1, n + 1):
                    for w in range(W + 1):
                        if weights[i-1] <= w:
                            dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
                        else:
                            dp[i][w] = dp[i-1][w]

                return dp[n][W]

            # Пример использования
            values = [60, 100, 120]
            weights = [10, 20, 30]
            W = 50
            print(knapsack(values, weights, W))  # Output: 220


    3. Задача о наибольшей общей подпоследовательности (Longest Common Subsequence, LCS)

        Даны две строки, нужно найти длину их наибольшей общей подпоследовательности.

        Боттом-ап подход:

            def lcs(X, Y):
                m = len(X)
                n = len(Y)
                dp = [[0] * (n + 1) for _ in range(m + 1)]

                for i in range(1, m + 1):
                    for j in range(1, n + 1):
                        if X[i - 1] == Y[j - 1]:
                            dp[i][j] = dp[i - 1][j - 1] + 1
                        else:
                            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

                return dp[m][n]

            # Пример использования
            X = "AGGTAB"
            Y = "GXTXAYB"
            print(lcs(X, Y))  # Output: 4 ("GTAB")



Преимущества и недостатки динамического программирования:

    Преимущества:

        Эффективность: Значительно уменьшает количество повторных вычислений.
        Оптимальность: Часто используется для нахождения оптимальных решений.
        Масштабируемость: Подходит для решения задач большого размера.

    Недостатки:

        Потребление памяти: Может требовать значительного объема памяти для хранения результатов подзадач.
        Сложность разработки: Разработка DP-алгоритмов может быть сложной и требовать глубокого анализа задачи.


Заключение

    Динамическое программирование является мощным методом для решения множества задач, где перекрывающиеся подзадачи
    и оптимальные подструктуры играют ключевую роль. Этот метод широко используется в различных областях,
    включая компьютерные науки, экономику и биоинформатику.
