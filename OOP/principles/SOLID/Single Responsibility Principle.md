
Принцип единственной ответственности (Single Responsibility Principle, SRP) - один из пяти основных
принципов SOLID в объектно-ориентированном программировании.
SRP определяет, что каждый класс должен быть ответственен только за одну конкретную часть
функциональности программы, и эта ответственность должна быть полностью инкапсулирована в классе.


Основные идеи SRP:

    Единственная причина для изменения:

        Каждый класс должен иметь только одну причину для изменения. Если класс выполняет несколько
        независимых задач и каждая из этих задач может измениться по-разному,
        это может привести к сложностям в поддержке и изменении класса.


    Выделение функциональности:

        Принцип SRP поощряет выделение конкретной функциональности в отдельные классы или модули.
        Это способствует уменьшению сложности кода, улучшению его читаемости и поддерживаемости.


    Улучшение тестируемости:

        Классы, соблюдающие SRP, часто проще тестировать, так как их ответственность легче оценить,
        и их поведение легче предсказать.



Пример нарушения SRP:

    Предположим, у нас есть класс Employee, который отвечает за хранение информации
    о сотруднике и одновременно за взаимодействие с базой данных для сохранения и загрузки данных.

    class Employee:
        def __init__(self, name, position):
            self.name = name
            self.position = position

        def save_to_database(self):
            # Сохранение информации о сотруднике в базу данных
            pass

        def load_from_database(self, employee_id):
            # Загрузка информации о сотруднике из базы данных
            pass

    Этот класс нарушает SRP, потому что он выполняет две разные функции:
    хранение информации о сотруднике и взаимодействие с базой данных.



Пример соблюдения SRP:

    Для соблюдения SRP мы можем разделить класс Employee на два отдельных класса:
    один для хранения информации о сотруднике и другой для взаимодействия с базой данных.

    class Employee:
        def __init__(self, name, position):
            self.name = name
            self.position = position

    class EmployeeRepository:
        def save_to_database(self, employee):
            # Сохранение информации о сотруднике в базу данных
            pass

        def load_from_database(self, employee_id):
            # Загрузка информации о сотруднике из базы данных
            pass

    В этом примере класс Employee отвечает только за хранение информации о сотруднике,
    а класс EmployeeRepository отвечает за взаимодействие с базой данных.
    Каждый класс имеет свою собственную, четко определенную ответственность,
    что соответствует принципу единственной ответственности.

